package edu.uwm.cs351;

import java.awt.Graphics;
import java.awt.Point;
import java.util.AbstractCollection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;

import javax.swing.Icon;

import junit.framework.TestCase;

/**
 * A piece in a game using hexagonal boards.
 * It uses the {@link Rank} to determine kind of piece.
 */
public class Piece {

	private final Team team;
	private final Rank rank;
	private HexCoordinate position;
	private Piece next, prev;

	private Piece() {
		team = null;
		rank = null; // not normally permitted.
		next = this; // needed for dummy node
		prev = this;
	}

	/** Create a piece with the given rank.
	 * @param t team for the piece, must not be null
	 * @param r rank to use, must not be null
	 */
	public Piece(Team t, Rank r) {
		if (t == null) throw new NullPointerException("Cannot use null team");
		if (r == null) throw new NullPointerException("cannot use null rank");
		team = t;
		rank = r;
	}

	public Team getTeam() { return team; }
	public Rank getRank() { return rank; }
	public HexCoordinate getPosition() { return position; }

	/**
	 * Set the position of this piece
	 * @param h hex coordinate, may be null
	 */
	public void setPosition(HexCoordinate h) {
		position = h;
	}

	@Override
	public String toString() {
		if (rank == null) return super.toString() + "<dummy>"; 
		String loc = (position == null) ? "<>" : position.toString();
		return team + "/" + rank + loc;
	}

	/**
	 * Create a piece using the information in the string as a guide.
	 * The string should have the format generated by {@link #toString()}
	 * @param s string to use to make piece, must not be null
	 * @return new piece with that string
	 * @exception FormatException the string is badly formatted.
	 * @exception IllegalArgumentException the string has an unknown team or rank.
	 */
	public static Piece fromString(String s) {
		int slash = s.indexOf('/');
		int pos = s.indexOf('<');
		if (slash < 0 || pos < slash || !s.endsWith(">")) throw new FormatException("Not in form T/R<..>: " + s);
		Team t = Team.valueOf(s.substring(0, slash));
		Rank r = Rank.valueOf(s.substring(slash+1,pos));
		String posString = s.substring(pos);
		HexCoordinate p = posString.equals("<>") ? null : HexCoordinate.fromString(posString); 
		Piece piece = new Piece(t,r);
		piece.setPosition(p);
		return piece;
	}

	/**
	 * Draw a piece on the board.
	 * @param g graphics context, must not be null
	 * @param width hexagon width
	 */
	public void draw(Graphics g, int width) {
		if (position == null) return;
		Icon i = rank.getIcon(team,width);
		int w = i.getIconWidth();
		int h = i.getIconHeight();
		Point p = position.toPoint(width);
		i.paintIcon(null, g, p.x-w/2, p.y-h/2);
	}

	/**
	 * An endogenous collection of pieces.
	 */
	public static class Collection extends AbstractCollection<Piece> {
		// the only fields:
		private final Piece dummy = new Piece();
		private int count = 0;
		private int version;

		private static boolean doReport = true;
		
		private boolean report(String message) {
			if (doReport) System.out.println("Invariant error: " + message);
			return false;
		}

		private boolean wellFormed() {
			// TODO: check data struture.
			
			/*Items to check for wellFormed
			 * Pieces are linked in a cycle with next and previous links
			 * Check size
			 */
			
			Iterator invariant = new MyIterator();
			Piece cursor;
			int checkCount = 0;
			
			while (invariant.hasNext())
			{
				
				cursor = (Piece) invariant.next();
				checkCount++;
				
				if (cursor.next == null || cursor.prev == null)
					return report ("There is a null pointer in the list.");
				
				if (cursor.rank == null)
					break;			//End loop when dummy node is reached.
				
			}
			
			if (checkCount != count)
				return report ("The number of items in the list: " + checkCount + " does not match the size of the list: " + count);
			
			return true;
		}

		/**
		 * Create an empty collection.
		 */
		public Collection() {
			this.add(dummy);
			//System.out.println(this.toString());
			assert wellFormed() : "invariant failed in constructor";
		}

		@Override // required by Java
		public Iterator<Piece> iterator() {
			assert wellFormed() : "invariant failed in iterator()";
			return new MyIterator(); // TODO
		}

		/* (non-Javadoc)
		 * @see java.util.AbstractCollection#add(java.lang.Object)
		 */
		@Override
		public boolean add(Piece e) {
			
			if (e == null)
				throw new NullPointerException("Unable to add a null element.");
			
			else if (e.next != e.prev)
				throw new IllegalArgumentException("Unable to add the same piece to multiple lists.");
			
			//Add new element to the front of the list
			
			e.next = dummy.next;
			e.prev = dummy;
			dummy.next = e;
			count++;
			
			return true;	// No need for a false return value as the exceptions cover those cases.
		}

		@Override // required by Java
		public int size() {
			assert wellFormed() : "invariant failed in size()";
			return count;
		}

		// TODO: What else?
		
		

		private class MyIterator implements Iterator<Piece> {
			private Piece current;
			private boolean canRemove;
			private int myVersion;

			public MyIterator() {
				// TODO: initialize fields 
				this.current = dummy;
				this.canRemove = false;
				this.myVersion = version;
			}

			private void checkStale() {
				// TODO: if the versions don't match, throw CME
				if (version != myVersion)
					throw new ConcurrentModificationException();
			}

			@Override // required by Java
			public boolean hasNext() {
				checkStale();
				
				if (current.next != null)
					return true;
				
			    return false; // TODO
			}

			@Override // required by Java
			public Piece next() {
				checkStale();
			    return current.next; // TODO
			}

			// TODO: what else ?
		}
	}
	
	public static class TestInvariant extends TestCase {
		private Collection self;
		private Piece ghost = new Piece();
		private Piece c[] = { null,
				new Piece(Team.GREEN,Rank.BOAT),
				new Piece(Team.BLUE,Rank.BOAT),
				new Piece(Team.RED,Rank.FOOT),
				new Piece(Team.BLUE,Rank.FOOT),
				new Piece(Team.BLUE,Rank.CAR),
				new Piece(Team.RED,Rank.CAR),	
				new Piece(Team.GREEN,Rank.HORSE),
		};
		private Piece d[] = { null, // doppelganger:
				new Piece(Team.GREEN,Rank.BOAT),
				new Piece(Team.BLUE,Rank.BOAT),
				new Piece(Team.RED,Rank.FOOT),
				new Piece(Team.BLUE,Rank.FOOT),
				new Piece(Team.BLUE,Rank.CAR),
				new Piece(Team.RED,Rank.CAR),	
				new Piece(Team.GREEN,Rank.HORSE),
		};

		@Override
		protected void setUp() {
			Collection.doReport = false;
			self = new Collection();
		}

		public void test0() {
			// self starts empty
			assertEquals(true,self.wellFormed());
			self.count = 1;
			assertEquals(false,self.wellFormed());
		}
		
		public void test1() {
			self.count = 1;
			self.dummy.next = c[1];
			assertEquals(false,self.wellFormed());
			c[1].next = self.dummy;
			assertEquals(false,self.wellFormed());
			c[1].prev = self.dummy;
			assertEquals(false,self.wellFormed());
			self.dummy.prev = c[1] = c[1];
			assertEquals(true,self.wellFormed());
			self.count = 0;
			assertEquals(false,self.wellFormed());
		}
		
		public void test2() {
			self.count = 1;
			self.dummy.next = c[1];
			c[1].next = self.dummy;
			c[1].prev = self.dummy;
			self.dummy.prev = d[1]; // duplicate piece
			d[1].next = self.dummy;
			d[1].prev = self.dummy;
			assertEquals(false,self.wellFormed());
		}

		public void test3() {
			self.count = 1;
			self.dummy.next = c[1];
			self.dummy.prev = c[1];
			c[1].next = self.dummy;
			c[1].prev = ghost;
			assertEquals(false,self.wellFormed());
			c[1].prev = self.dummy;
			c[1].next = ghost;
			ghost.prev = c[1];
			ghost.next = c[1];
			assertEquals(false,self.wellFormed());
		}
		
		public void test4() {
			self.count = 2;
			self.dummy.next = c[3];
			c[3].next = c[4];
			c[4].next = self.dummy;
			assertFalse(self.wellFormed());
			c[4].prev = c[3];
			assertFalse(self.wellFormed());
			c[3].prev = self.dummy;
			assertFalse(self.wellFormed());
			self.dummy.prev = c[3];
			assertFalse(self.wellFormed());
			self.dummy.prev = c[4];
			assertTrue(self.wellFormed());
		}

		public void test5() {
			self.count = 3;
			self.dummy.next = c[1];
			c[1].next = c[2];
			c[2].next = c[1];
			c[1].prev = c[2];
			c[2].prev = c[1];
			self.dummy.prev = c[3];
			c[3].prev = c[2];
			c[3].next = self.dummy;
			assertFalse(self.wellFormed());
			c[1].prev = self.dummy;
			assertFalse(self.wellFormed());
			c[2].next = c[3];
			assertTrue(self.wellFormed());
		}

		public void test6() {
			self.count = 4;
			self.dummy.next = c[1];
			c[1].next = c[2]; 
			c[2].next = c[3]; 
			c[3].next = c[4];
			c[4].next = self.dummy;
			self.dummy.prev = c[4];
			c[4].prev = d[3]; d[3].next = c[4]; d[3].prev = d[2];
			c[3].prev = d[2]; d[2].next = c[3]; d[2].prev = d[1];
			c[2].prev = d[1]; d[1].next = c[2]; d[1].prev = self.dummy;
			c[1].prev = ghost; ghost.next = c[1]; ghost.prev = c[4];
			assertFalse(self.wellFormed());
			c[1].prev = self.dummy;
			assertFalse(self.wellFormed());
			c[2].prev = c[1];
			assertFalse(self.wellFormed());
			c[3].prev = c[2];
			assertFalse(self.wellFormed());
			c[4].prev = c[3];
			assertTrue(self.wellFormed());
		}

		public void test7() {
			self.count = 4;
			self.dummy.next = c[1];
			c[1].next = c[2]; 
			c[2].next = c[3]; 
			c[3].next = c[4];
			c[4].next = self.dummy;
			self.dummy.prev = c[4];
			c[4].prev = c[3];
			c[3].prev = c[2];
			c[2].prev = c[1];
			c[1].prev = self.dummy;
			assertTrue(self.wellFormed());
			c[3].next = c[1];
			assertFalse(self.wellFormed());
			c[3].next = c[2];
			assertFalse(self.wellFormed());
			c[3].next = c[3];
			assertFalse(self.wellFormed());
		}

		public void test8() {
			self.count = 0;
			self.dummy.next = self.dummy.prev = null;
			assertFalse(self.wellFormed());
		}

		public void test9() {
			self.count = 3;
			self.dummy.next = c[1]; c[1].prev = self.dummy;
			c[1].next = c[2]; c[2].prev = c[1];
			c[2].next = c[3]; c[3].prev = c[2];
			c[3].next = null; self.dummy.prev = c[3];
			assertEquals(false,self.wellFormed());
		}
	}

}
